"use strict";(self.webpackChunkasync_stream_blog=self.webpackChunkasync_stream_blog||[]).push([[421],{6163:function(e,t,n){n.d(t,{A:function(){return r}});var a=n(6540),i=n(4848);function s({id:e,host:t,repo:s,repoId:r,category:o,categoryId:l,mapping:c,term:h,strict:m,reactionsEnabled:d,emitMetadata:u,inputPosition:p,theme:f,lang:g,loading:y}){const[w,v]=(0,a.useState)(!1);return(0,a.useEffect)((()=>{w||n.e(416).then(n.bind(n,416)).then((()=>v(!0)))}),[]),w?(0,i.jsx)("giscus-widget",{id:e,host:t,repo:s,repoid:r,category:o,categoryid:l,mapping:c,term:h,strict:m,reactionsenabled:d,emitmetadata:u,inputposition:p,theme:f,lang:g,loading:y}):null}var r=()=>a.createElement("div",{className:"comments-wrapper"},a.createElement(s,{repo:"jhellerstein/blog",repoId:"R_kgDOOlLShQ",category:"Comments",categoryId:"DIC_kwDOOlLShc4CqUp7",mapping:"pathname",term:"Welcome to the async stream blog.",strict:"0",reactionsEnabled:"1",emitMetadata:"0",inputPosition:"bottom",theme:"light",lang:"en",loading:"lazy",crossOrigin:"anonymous",async:!0}))},9573:function(e,t,n){n.r(t),n.d(t,{Head:function(){return p},default:function(){return f}});var a=n(8453),i=n(6540),s=(n(33),n(8693));function r(e){const t=Object.assign({h2:"h2",p:"p",em:"em",ol:"ol",li:"li",strong:"strong",hr:"hr",h3:"h3",span:"span",blockquote:"blockquote"},(0,a.RP)(),e.components);return i.createElement(i.Fragment,null,i.createElement(t.h2,null,"Three Sets of Specs (for Staying in Spec)"),"\n",i.createElement(t.p,null,"In the last post I talked about how systems formalisms are like sculpting with\na chisel: we remove behaviors we don’t want, and what remains is correct.\nThis subtractive view shows up as system invariants. Concurrent actions\nshouldn’t conflict. Replicas shouldn’t drift beyond reconciliation.\nDeadlocks should be impossible.\nIn short, systems have to stay within specification."),"\n",i.createElement(t.p,null,"In this post we turn our attention to the work at hand:\n",i.createElement(t.em,null,"When is staying within spec easy, and when is it hard?"),"."),"\n",i.createElement(t.p,null,"If you work on systems, you’ve almost certainly felt that some of these\ninvariants seem to maintain themselves, while others require careful\ndesign and constant vigilance. They look similar on the surface, but\nbehave very differently in practice."),"\n",i.createElement(t.p,null,"This can be hard to reason about because the same underlying difficulty\nkeeps reappearing in different guises. Sometimes it shows up as waiting.\nSometimes as ordering. Sometimes as questions about what the system\nexposes to observers, and when."),"\n",i.createElement(t.p,null,'In this post, I’ll look at these issues through three different pairs of\n"specs"—three ways engineers tend to first ',i.createElement(t.em,null,"notice")," that staying within spec\nhas become tricky:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Waiting"),": when do we have to wait, and what are we waiting for?"),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Ordering"),": how much order do we really need to impose?"),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Commitment"),": what kinds of claims does the system expose to observers, and stick with?"),"\n"),"\n",i.createElement(t.p,null,"We won’t do formal theory, and we won’t build protocols. The goal is to\nconnect these different viewpoints and show how they fit together.\nOnly at the end will we return to a practical question systems people\ncare about: when do we actually need extra machinery—and when don’t we?"),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,null,"Lens 1: Waiting. “Come one vs. Come all”"),"\n",i.createElement(t.p,null,"We don’t like to wait in computing, but sometimes we ",i.createElement(t.em,null,"have")," to in order to stay within spec.\nWaiting is undesirable for many reasons: added latency, context-switch overheads,\nrisks of unavailability or deadlock. But at bottom, there are only two fundamental ",i.createElement(t.em,null,"reasons")," we wait:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"Waiting for something to happen"),"\n",i.createElement(t.li,null,"Waiting to know that nothing else will happen"),"\n"),"\n",i.createElement(t.p,null,"Let's take these one at a time."),"\n",i.createElement(t.h3,null,"Waiting for something"),"\n",i.createElement(t.p,null,"The first category is the familiar one. The clearest example is a ",i.createElement(t.em,null,"data dependency"),".\nIf my job is to compute the function ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x + y</code>'}}),", I have to wait until the values of ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x</code>'}}),"\nand ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">y</code>'}})," are available (and perhaps the instruction for ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">+</code>'}}),", if we’re thinking at the chip level).\nThat’s easy to understand, and it’s easy to implement. The computation becomes ready exactly\nwhen its inputs arrive."),"\n",i.createElement(t.p,null,"So far so good. But many cases of “waiting for something to happen”\n",i.createElement(t.em,null,"feel"),' more complicated: they\'re not about passing data, they involve some\nnotion of "control" messages. Nonetheless, many of these cases fall in this same category.'),"\n",i.createElement(t.p,null,"One that students often ask about is message acknowledgment. I send you a message:\n“",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">2 + 2 = 4</code>'}}),".” Once I receive an ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ack: 2 + 2 = 4</code>'}}),' from you, I know you’ve received it,\nand I can proceed with that knowledge in hand—perhaps freeing the memory holding the\ninputs and output. Until then, I’m waiting at your mercy. If you’re slow to respond,\nI’m stuck. This can feel like a different kind of waiting—after all, I\'m waiting for\n“control” messages that are irrelevant to the "data" in my computation.'),"\n",i.createElement(t.p,null,"But this setting is not materially different from a function call. In a single-threaded program,\nif my code calls a (local) function ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x + y</code>'}}),", I can’t proceed as if ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x + y</code>'}})," has completed\nuntil the function returns. The return isn’t permission or agreement; it’s evidence that the work I\ndepend on has finished. The distributed acknowledgment plays the same role: it’s the signal\nthat the step I depend on has completed."),"\n",i.createElement(t.p,null,"A function return doesn’t involve another machine, but the need to wait is already there.\nThe distributed case doesn’t introduce a new kind of dependency—it just stretches an existing one\nacross a network."),"\n",i.createElement(t.p,null,"These ‘waiting for something’ cases are all instances of causal dependence on available evidence:\nonce the needed event is observed, the waiting is over."),"\n",i.createElement(t.h3,null,"Waiting for nothing…or everyone"),"\n",i.createElement(t.p,null,"As a contrast, consider a different scenario: distributed termination detection."),"\n",i.createElement(t.p,null,"Imagine I’ve paid for a global network of machines to work on a problem\nfor me, and I want to know when that computation is finished.\nIntuitively, the computation is done when two conditions both hold:\n(i) no machine is currently taking steps on my behalf, and (ii) there\nare no messages in flight that could trigger further steps."),"\n",i.createElement(t.p,null,"That sounds reasonable—but how do I establish those facts?\nWho’s to say that some machine won’t wake up a minute from now—or a year\nfrom now—and resume work? Who’s to say that a message isn’t delayed\nsomewhere in the network, ready to reignite the computation?"),"\n",i.createElement(t.p,null,"What I’m waiting for here is very different from the earlier examples.\nI’m not waiting for a particular event to arrive. I’m waiting for a\nguarantee that ",i.createElement(t.em,null,"nothing else will happen"),". Formally, what I want to know\nis something like:"),"\n",i.createElement(t.blockquote,null,"\n",i.createElement(t.p,null,"There exists no machine still working for me, and there exists no\nmessage in flight on my behalf."),"\n"),"\n",i.createElement(t.p,null,"That kind of claim doesn’t follow from causality. Causality tells me how\nevents relate once they happen; it doesn’t tell me that no further events\nare possible."),"\n",i.createElement(t.p,null,"Put differently, “nothing exists” is a universal claim (hello, DeMorgan!). To conclude\nthat no machine is still working, I need confirmation from every\nmachine. Waiting for nothing quietly turns into waiting to hear from\neveryone."),"\n",i.createElement(t.p,null,"That reframing explains why this kind of waiting feels so different. In\nthe earlier cases, progress was triggered by arrival. Here, progress\ndepends on establishing a global absence. And absences don’t announce\nthemselves."),"\n",i.createElement(t.p,null,"This also exposes two immediate complications. First, I need to know who\ncounts as “everyone.” If machines can join dynamically, or if the set of\nparticipants isn’t fixed, the target keeps moving. Second, even if I do\nknow the full roster, what happens if one machine is slow, unreachable,\nor has failed? Am I allowed to proceed without hearing from it? On what\nbasis?"),"\n",i.createElement(t.p,null,"These questions simply don’t arise when waiting for something to happen.\nOnce an input arrives, the dependency is satisfied and computation can\nmove forward locally. Waiting for non-arrival, by contrast, asks the\nsystem to make a claim about the future: that no further relevant events\nwill occur."),"\n",i.createElement(t.p,null,"This distinction—between waiting for arrival and waiting for guaranteed\nabsence—is well known in distributed systems. It shows up in classic\nwork on termination detection, and more abstractly in results like CALM,\nwhich formalize reasoning from positive evidence versus reasoning from absence.\nBut even without the theory, the difference is visible operationally.\nOne kind of waiting is driven by evidence. The other is driven by\nexhaustion."),"\n",i.createElement(t.p,null,"And that’s the tension to keep in mind as we move on. Waiting for\nsomething lets the system react. Waiting for nothing forces the\nsystem to make a claim about the\nfuture. Ordering turns out to do the same thing."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,null,"Lens 2: Order — partial orders and the cost of total order"),"\n",i.createElement(t.p,null,"Ordering problems often feel different from waiting problems, but\nthey create pressure in a similar way."),"\n",i.createElement(t.p,null,"Causal events naturally form a partial order: a DAG of events with\n“happens-before” edges. Many events are independent—they race, overlap,\nand arrive in different orders at different machines. In many systems,\nthat’s enough. Replicas extend the partial order as events arrive, and the set of\nevent vertices and “happens-before” edges accumulates (in arbitrary order) at all replicas.\nThis works only because information is added monotonically as evidence arrives,\nand is never retracted."),"\n",i.createElement(t.p,null,"But sometimes a system asks for more than a partial order. Sometimes it\nwants a ",i.createElement(t.em,null,"total")," order: every event must be placed in a single sequence."),"\n",i.createElement(t.p,null,"This comes up in very familiar places. Linearizability asks us to\nexplain a concurrent execution as if operations happened one at a time.\nSerializability asks us to pretend that transactions ran sequentially.\nIn both cases, the goal is to emulate a single-threaded program on top\nof a concurrent or distributed system."),"\n",i.createElement(t.p,null,"At first glance, this may not seem like a big step. After all, many total\norders are consistent with a given partial order. Why not just pick one?"),"\n",i.createElement(t.p,null,"The surprise is how sharp the boundary is."),"\n",i.createElement(t.p,null,"A partial order grows naturally as events arrive. If two events are\nindependent, the system can wait. Their relative order doesn’t matter\nyet, and it may never need to be fixed."),"\n",i.createElement(t.p,null,"A total order doesn’t have that flexibility. It forces the system to\ndecide the order of events that race—even when there is no causal reason\nto do so, and even when not all contenders have been seen yet."),"\n",i.createElement(t.p,null,"Once such a decision is made, it becomes a commitment—an assumption that\nthe system must keep true, not a preference or intent.\nAnother replica,\nobserving the same events in a different order, may make a different\ncommitment. Those choices don’t fit together. Reconciling them later\nmeans undoing something: replaying, rolling back, or preventing the\ndivergence from happening in the first place."),"\n",i.createElement(t.p,null,"This is why systems that promise linearizability or serializability end\nup doing so much extra work. The cost isn’t in maintaining order where\ncausality already demands it. The cost is in committing early, before\nthe system has seen enough to know which total orders will remain\ncompatible with future events."),"\n",i.createElement(t.p,null,"That’s the tension to keep in mind. Partial orders let the system defer\ndecisions. Total order forces it to decide—and to live with the\nconsequences."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,null,"Lens 3: What the system is willing to stand by"),"\n",i.createElement(t.p,null,"Replication has been implicit in the earlier lenses; now we’ll make it explicit.\nBoth waiting and ordering become difficult for the same underlying\nreason, which only shows up clearly once we look at replication."),"\n",i.createElement(t.p,null,"In a distributed system, there isn’t just one place where events are\nobserved or extended. There are many. Different replicas may see events\nin different orders, at different times, and may make progress\nindependently. Any statement the system makes has to survive that fact."),"\n",i.createElement(t.p,null,"In the easy cases, this works out surprisingly well."),"\n",i.createElement(t.p,null,"As we saw in the previous section, claims like “a happened before b” are\nsafe in a replicated system because they can only be strengthened by\nlater information, never contradicted.\nBecause of this, replicas can extend a partial order independently.\nNew information is added to the sets of events and relationships, but never requires earlier\ninformation to be revisited. Progress at one replica doesn’t put it at odds\nwith progress at another."),"\n",i.createElement(t.p,null,"The hard cases begin when the system wants to say something stronger."),"\n",i.createElement(t.p,null,"“Nothing else will happen.”\n“This result is final.”\n“This is the total order.”"),"\n",i.createElement(t.p,null,"These statements don’t just summarize the past. They also rule out\npossibilities about the future."),"\n",i.createElement(t.p,null,"In a total order, the system doesn’t merely assert that\n“event a happened before event b.”\nIt also asserts that ",i.createElement(t.em,null,"nothing else can come between a and b"),".\nThat second clause is easy to overlook, but it’s doing all the work."),"\n",i.createElement(t.p,null,"Once a replica makes such a claim, it is committing to a particular\nexplanation of the execution and promising that any future events will\nfit into it. In a replicated system, that promise has to be shared."),"\n",i.createElement(t.p,null,"And it can be broken."),"\n",i.createElement(t.p,null,"Another replica may still observe a delayed event c that naturally\nbelongs between a and b.\nTwo replicas may already have committed to incompatible explanations.\nNew information may arrive that doesn’t fit the story told so far."),"\n",i.createElement(t.p,null,"The same pattern shows up with waiting.\nWaiting for arrival works because evidence resolves uncertainty locally,\nand replicas can reconcile later.\nWaiting for non-arrival is harder because it asks all replicas to agree\nthat no further relevant events will appear."),"\n",i.createElement(t.p,null,"Seen this way, the earlier lenses line up."),"\n",i.createElement(t.p,null,"Partial orders work because they assert only what evidence forces and\nremain silent about everything else.\nTotal order is brittle because it requires the system to exclude entire\nclasses of future observations."),"\n",i.createElement(t.p,null,"In all of these cases, the underlying question is the same:\nwhat kinds of statements can replicas make independently, and what kinds\nof statements require them to act together in order to remain true?"),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,null,"Conclusion: when you need a chisel"),"\n",i.createElement(t.p,null,"Throughout this post, we’ve been looking at how systems stay within\nspec—by ruling out behaviors they won’t allow. What the three lenses\nshow is that there are two very different ways this happens."),"\n",i.createElement(t.p,null,"In the easy cases, possible futures disappear on their own."),"\n",i.createElement(t.p,null,"When a system reacts to evidence, new events make some futures impossible\nsimply by occurring. Once a message arrives, futures in which it never\narrived are gone. Once a causal relationship is observed (i.e., arrival\nof a piece of evidence establishing dependency), futures that\nviolate it are no longer consistent with the history. As information\naccumulates, the space of possible executions shrinks in a way that is\nforced by the inputs themselves."),"\n",i.createElement(t.p,null,"This is why replicas can diverge temporarily and still reconcile.\nThey may see events in different orders, but as they exchange\ninformation, their views converge. Evidence removes ambiguity on its\nown, without anyone having to declare which futures are allowed."),"\n",i.createElement(t.p,null,"The hard cases are different."),"\n",i.createElement(t.p,null,"Here, the system wants to rule out futures that the world has not ruled\nout yet. It wants to say that nothing else will happen, that a result is\nfinal, or that a particular ordering is settled and cannot be revised.\nThose futures are not impossible—they are merely unwanted."),"\n",i.createElement(t.p,null,"At that point, the system can no longer rely on monotonic accumulation\nalone. The passage of events will not do the work for it. To stay within\nspec, the system has to actively forbid certain futures and get all\nparticipants to respect that decision."),"\n",i.createElement(t.p,null,"That is what we usually call coordination."),"\n",i.createElement(t.p,null,"Coordination is not about slowness or synchronization for its own sake.\nIt is the extra machinery a system needs when correctness depends on\nexcluding futures that might otherwise still occur."),"\n",i.createElement(t.p,null,"This distinction shows up again and again: in transactions and\nisolation levels, in bulk-synchronous execution, and in systems that\nmust act before all uncertainty is resolved. Those connections are\nworth exploring, but they’re for later posts."),"\n",i.createElement(t.p,null,"For now, the takeaway is this. If the futures you want to rule out will\nbe ruled out anyway by the arrival of information, staying within spec\nis easy. If they won’t be, the system will need help."))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?i.createElement(t,e,i.createElement(r,e)):r(e)},l=n(2532),c=n(4967),h=n(3895),m=n(7528),d=n(6163);const u=e=>{var t;let{data:n,location:a,children:r}=e;const o=n.mdx,m=(null===(t=n.site.siteMetadata)||void 0===t?void 0:t.title)||"Title",u=(0,l.c)(o.frontmatter.coverImage),p=o.frontmatter.coverImageCaption;return i.createElement(h.A,{location:a,title:m},i.createElement("article",{className:"blog-post",itemScope:!0,itemType:"http://schema.org/Article"},i.createElement("header",null,i.createElement("h1",{className:"blog-post-title",itemProp:"headline"},o.frontmatter.title),i.createElement("p",null,o.frontmatter.date," • ",o.fields.readingTime),u&&i.createElement("div",{style:{width:"30%",float:"right",marginLeft:"2rem",marginBottom:"2rem",background:"#fafaff",border:"1px solid #eee",borderRadius:"8px",boxShadow:"0 2px 8px rgba(0,0,0,0.04)",padding:"1rem"}},i.createElement(l.G,{image:u,alt:o.frontmatter.title,style:{width:"100%",borderRadius:"4px",marginBottom:p?"0.5rem":"0"}}),p&&p.trim()&&i.createElement("figcaption",{className:"cover-image-caption",style:{textAlign:"left",color:"#666",fontSize:"0.85rem",lineHeight:"1.4",margin:"0"},dangerouslySetInnerHTML:{__html:p}}))),i.createElement("section",{className:"content",itemProp:"articleBody"},r),i.createElement("hr"),i.createElement("footer",null,i.createElement(c.A),i.createElement(d.A))),i.createElement("nav",{className:"blog-post-nav"},i.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0}},i.createElement("li",null,n.previous&&i.createElement(s.Link,{to:n.previous.fields.slug,rel:"prev"},"← ",n.previous.frontmatter.title)),i.createElement("li",null,n.next&&i.createElement(s.Link,{to:n.next.fields.slug,rel:"next"},n.next.frontmatter.title," →")))))},p=e=>{let{data:t}=e;return i.createElement(m.A,{title:t.mdx.frontmatter.title,description:t.mdx.frontmatter.description||t.mdx.excerpt})};function f(e){return i.createElement(u,e,i.createElement(o,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-content-blog-three-specs-on-specs-index-mdx-7961cadb92a9de5266b1.js.map