"use strict";(self.webpackChunkasync_stream_blog=self.webpackChunkasync_stream_blog||[]).push([[421],{6163:function(e,t,n){n.d(t,{A:function(){return i}});var a=n(6540),s=n(4848);function r({id:e,host:t,repo:r,repoId:i,category:o,categoryId:l,mapping:c,term:h,strict:m,reactionsEnabled:d,emitMetadata:u,inputPosition:p,theme:g,lang:f,loading:y}){const[w,b]=(0,a.useState)(!1);return(0,a.useEffect)((()=>{w||n.e(416).then(n.bind(n,416)).then((()=>b(!0)))}),[]),w?(0,s.jsx)("giscus-widget",{id:e,host:t,repo:r,repoid:i,category:o,categoryid:l,mapping:c,term:h,strict:m,reactionsenabled:d,emitmetadata:u,inputposition:p,theme:g,lang:f,loading:y}):null}var i=()=>a.createElement("div",{className:"comments-wrapper"},a.createElement(r,{repo:"jhellerstein/blog",repoId:"R_kgDOOlLShQ",category:"Comments",categoryId:"DIC_kwDOOlLShc4CqUp7",mapping:"pathname",term:"Welcome to the async stream blog.",strict:"0",reactionsEnabled:"1",emitMetadata:"0",inputPosition:"bottom",theme:"light",lang:"en",loading:"lazy",crossOrigin:"anonymous",async:!0}))},9573:function(e,t,n){n.r(t),n.d(t,{Head:function(){return p},default:function(){return g}});var a=n(8453),s=n(6540),r=(n(33),n(8693));function i(e){const t=Object.assign({h2:"h2",p:"p",em:"em",ol:"ol",li:"li",strong:"strong",hr:"hr",h3:"h3",span:"span",blockquote:"blockquote"},(0,a.RP)(),e.components);return s.createElement(s.Fragment,null,s.createElement(t.h2,null,"Three Sets of Specs (for Staying in Spec)"),"\n",s.createElement(t.p,null,"In the last post I talked about how systems formalisms are like sculpting with\na chisel: we remove behaviors we don’t want, and what remains is correct.\nThis subtractive view shows up as system invariants: concurrent actions\nshouldn’t conflict, replicas shouldn’t drift beyond reconciliation, and\ndeadlocks should be impossible."),"\n",s.createElement(t.p,null,"In this post we turn our attention to the work at hand:\n",s.createElement(t.em,null,"When is staying within spec easy, and when is it hard?"),"."),"\n",s.createElement(t.p,null,"This can be hard to reason about because the same underlying difficulty keeps reappearing in different guises.\nSometimes it shows up as waiting. Sometimes as ordering. Sometimes as\nquestions about what the system exposes to observers, and when."),"\n",s.createElement(t.p,null,'In this post, I’ll look at these issues through three different pairs of\n"specs"—three ways engineers tend to first ',s.createElement(t.em,null,"notice")," that staying within spec\nhas become tricky:"),"\n",s.createElement(t.ol,null,"\n",s.createElement(t.li,null,s.createElement(t.strong,null,"Waiting"),": when do we have to wait, and what are we waiting for?"),"\n",s.createElement(t.li,null,s.createElement(t.strong,null,"Ordering"),": how much order do we really need to impose?"),"\n",s.createElement(t.li,null,s.createElement(t.strong,null,"Commitment"),": what kinds of claims does the system expose to observers, and stick with?"),"\n"),"\n",s.createElement(t.p,null,"We won’t do formal theory, and we won’t build protocols. The goal is to\nconnect these different viewpoints and show how they fit together.\nOnly at the end will we return to a practical question systems people\ncare about: when do we actually need extra machinery—and when don’t we?"),"\n",s.createElement(t.hr),"\n",s.createElement(t.h2,null,"Lens 1: Waiting. “Come one vs. Come all”"),"\n",s.createElement(t.p,null,"We don’t like to wait in computing, but sometimes we ",s.createElement(t.em,null,"have")," to in order to stay within spec.\nWaiting adds latency and can risk unavailability or deadlock. But at bottom, there are only two fundamental ",s.createElement(t.em,null,"reasons")," we wait:"),"\n",s.createElement(t.ol,null,"\n",s.createElement(t.li,null,"Waiting for something to happen"),"\n",s.createElement(t.li,null,"Waiting to know that nothing else will happen"),"\n"),"\n",s.createElement(t.h3,null,"Waiting for something"),"\n",s.createElement(t.p,null,"The first category is the familiar one. The clearest example is a ",s.createElement(t.em,null,"data dependency"),".\nIf my job is to compute the function ",s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x + y</code>'}}),", I have to wait until the values of ",s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x</code>'}}),"\nand ",s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">y</code>'}})," are available (and perhaps the instruction for ",s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">+</code>'}}),", if we’re thinking at the chip level).\nThat’s easy to understand, and it’s easy to implement. The computation becomes ready exactly\nwhen its inputs arrive."),"\n",s.createElement(t.p,null,"But many cases of “waiting for something to happen”\n",s.createElement(t.em,null,"feel"),' more complicated: they\'re not about passing data, they involve some\nnotion of "control" messages. Nonetheless, many of these cases fall in this same category.'),"\n",s.createElement(t.p,null,"Consider message acknowledgment. I send you a message:\n“",s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">msg m: 2 + 2 = 4</code>'}}),'.” Once I receive an "',s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ack: m</code>'}}),'" from you, I know you’ve received it,\nand I can proceed with that knowledge in hand—perhaps freeing the memory holding the\ninputs and output. Until then, I’m waiting at your mercy. If you’re slow to respond,\nI’m stuck. This can feel like a different kind of waiting—after all, I\'m waiting for\n“control” messages that are irrelevant to the "data" in my computation.'),"\n",s.createElement(t.p,null,"But this setting is not materially different from a function call. In a single-threaded program,\nif my code calls a (local) function ",s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x + y</code>'}}),", I can’t proceed as if ",s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">x + y</code>'}})," has completed\nuntil the function returns. The return isn’t permission or agreement; it’s evidence that the work I\ndepend on has finished. The distributed acknowledgment plays the same role: it’s the signal\nthat the step I depend on has completed."),"\n",s.createElement(t.p,null,"A function return doesn’t involve another machine, but the need to wait is already there.\nThe distributed case doesn’t introduce a new kind of dependency—it just stretches an existing one\nacross a network."),"\n",s.createElement(t.p,null,"These ‘waiting for something’ cases are all instances of causal dependence on available evidence:\nonce the needed event is observed, the waiting is over."),"\n",s.createElement(t.h3,null,"Waiting for nothing…or everyone"),"\n",s.createElement(t.p,null,"As a contrast, consider a different scenario: distributed termination detection."),"\n",s.createElement(t.p,null,"Imagine I’ve paid for a global network of machines to work on a problem\nfor me, and I want to know when that computation is finished.\nIntuitively, the computation is done when two conditions both hold:\n(i) no machine is currently taking steps on my behalf, and (ii) there\nare no messages in flight that could trigger further steps."),"\n",s.createElement(t.p,null,"That sounds reasonable—but how do I establish those facts?\nWho’s to say that a message isn’t delayed somewhere in the network, ready to reignite the computation?"),"\n",s.createElement(t.p,null,"What I’m waiting for here is very different from the earlier examples.\nI’m not waiting for a particular event to arrive. I’m waiting for a\nguarantee that ",s.createElement(t.em,null,"nothing else will happen"),". Formally, what I want to know\nis something like:"),"\n",s.createElement(t.blockquote,null,"\n",s.createElement(t.p,null,"There exists no machine still working for me, and there exists no\nmessage in flight on my behalf."),"\n"),"\n",s.createElement(t.p,null,"That kind of claim doesn’t follow from causality. Causality tells me how\nevents relate once they happen; it doesn’t tell me that no further events\nare possible."),"\n",s.createElement(t.p,null,"Put differently, “nothing exists” is a universal claim (hello, DeMorgan!). To conclude\nthat no machine is still working, I need confirmation from every\nmachine. Waiting for nothing quietly turns into waiting to hear from\neveryone."),"\n",s.createElement(t.p,null,"That reframing explains why this kind of waiting feels so different. In\nthe earlier cases, progress was triggered by arrival. Here, progress\ndepends on establishing a global absence. And absences don’t announce\nthemselves."),"\n",s.createElement(t.p,null,"This also exposes two immediate complications. First, I need to know who\ncounts as “everyone.” If machines can join dynamically, or if the set of\nparticipants isn’t fixed, the target keeps moving. Second, even if I do\nknow the full roster, what happens if one machine is slow, unreachable,\nor has failed? Am I allowed to proceed without hearing from it? On what\nbasis?"),"\n",s.createElement(t.p,null,"These questions simply don’t arise when waiting for something to happen.\nOnce an input arrives, the dependency is satisfied and computation can\nmove forward locally. Waiting for non-arrival, by contrast, asks the\nsystem to make a claim about the future: that no further relevant events\nwill occur."),"\n",s.createElement(t.p,null,"This distinction—between waiting for arrival and waiting for guaranteed\nabsence—is well known in distributed systems. It shows up in classic\nwork on termination detection, and more abstractly in results like CALM,\nwhich formalize reasoning from positive evidence versus reasoning from absence.\nOne kind of waiting is driven by evidence. The other is driven by exhaustion."),"\n",s.createElement(t.p,null,"And that’s the tension to keep in mind as we move on. Waiting for\nsomething lets the system react. Waiting for nothing forces the\nsystem to make a claim about the future. Ordering turns out to do the same thing."),"\n",s.createElement(t.hr),"\n",s.createElement(t.h2,null,"Lens 2: Order — partial orders and the cost of total order"),"\n",s.createElement(t.p,null,"Ordering problems often feel different from waiting problems, but\nthey create pressure in a similar way."),"\n",s.createElement(t.p,null,"Causal events naturally form a partial order: a DAG of events with\n“happens-before” edges. Many events are independent—they race, overlap,\nand have no inherent order between them. A partial order captures exactly\nwhat must be ordered, and no more."),"\n",s.createElement(t.p,null,"But sometimes a system asks for more than a partial order. Sometimes it\nwants a ",s.createElement(t.em,null,"total")," order: every event must be placed in a single sequence."),"\n",s.createElement(t.p,null,"This comes up in very familiar places. Linearizability asks us to\nexplain a concurrent execution as if operations happened one at a time.\nSerializability asks us to pretend that transactions ran sequentially.\nIn both cases, the goal is to emulate a single-threaded program."),"\n",s.createElement(t.p,null,"At first glance, this may not seem like a big step. After all, many total\norders are consistent with a given partial order. Why not just pick one?"),"\n",s.createElement(t.p,null,"The answer is that a total order asserts strictly more than a partial one.\nIt doesn’t merely say “event a happened before event b.”\nIt also says that ",s.createElement(t.strong,null,"nothing else can come between a and b"),"."),"\n",s.createElement(t.p,null,"That second clause is a claim about unseen events.\nHere, “unseen” includes future events, and events that are delayed in reaching you."),"\n",s.createElement(t.p,null,"A partial order can grow naturally as events occur. If two events are\nindependent, their relative order can remain unspecified, possibly\nforever."),"\n",s.createElement(t.p,null,"A total order removes that freedom. It forces a decision about the order\nof racing events—even when there is no causal reason to decide, and even\nwhen not all relevant events have yet occurred."),"\n",s.createElement(t.p,null,"Once such a decision is made, it cannot be taken back without revising\nthe history being asserted."),"\n",s.createElement(t.p,null,"This is why systems that promise linearizability or serializability end\nup doing so much extra work. The cost isn’t in maintaining order where\ncausality already demands it. The cost is in committing early, before\nthe system has seen enough to know which total orders will remain\ncompatible with future events."),"\n",s.createElement(t.p,null,"That’s the tension to keep in mind. Partial orders let the system defer\ndecisions. Total order forces it to decide—and to live with the\nconsequences."),"\n",s.createElement(t.hr),"\n",s.createElement(t.h2,null,"Lens 3: What the system is willing to expose"),"\n",s.createElement(t.p,null,"So far we’ve talked about waiting and ordering as properties of how a\nsystem executes. The final lens shifts perspective: from execution to\n",s.createElement(t.strong,null,"observation"),"."),"\n",s.createElement(t.p,null,"In a distributed system, there is no single place where events are\nobserved or understood. There are many replicas, each learning about\nthe world at different times and in different orders. Any statement the\nsystem exposes to the outside world has to survive that fact."),"\n",s.createElement(t.p,null,"In the easy cases, this works out well."),"\n",s.createElement(t.p,null,"Statements like “this message arrived,” or “event a happened before\nevent b,” are reports of observed evidence. They may be learned at\ndifferent times by different replicas, but they do not conflict.\nLater information can add detail or context, but it will not make the\nstatement false."),"\n",s.createElement(t.p,null,"Because of this, replicas can safely expose such facts independently.\nObservers may see partial information, but what they see will only be\nextended, never retracted. The system’s public story grows by\naccumulating evidence."),"\n",s.createElement(t.p,null,"The hard cases arise when the system exposes stronger claims."),"\n",s.createElement(t.p,null,"“Nothing else will happen.”\n“This result is final.”\n“This is the order.”"),"\n",s.createElement(t.p,null,"These are not just summaries of what has been observed so far. They are\nassertions that rule out future observations."),"\n",s.createElement(t.p,null,"Once such a claim is made public, the system is committed to it. Future\nevents must be handled in a way that preserves the claim—even if those\nevents have not yet been seen everywhere, or at all."),"\n",s.createElement(t.p,null,"This is where replication becomes a problem."),"\n",s.createElement(t.p,null,"One replica may expose a claim based on the information it has, while\nanother replica is still in a position to observe something that\ncontradicts it. An observer may learn the claim before the evidence\nneeded to justify it has fully propagated. At that point, the system\ncannot simply “update” the observer’s view without violating the\nmeaning of what it already said."),"\n",s.createElement(t.p,null,"The same pattern we saw in the earlier lenses reappears here."),"\n",s.createElement(t.p,null,"Waiting for arrival is easy because exposing evidence cannot be\ninvalidated by later events. Waiting for non-arrival is hard because it\nexposes an absence that might still be contradicted."),"\n",s.createElement(t.p,null,"Partial order is easy because exposing causal relationships can only be\nstrengthened by more information. Total order is hard because exposing\nit rules out alternative explanations that might still be consistent\nwith unseen events."),"\n",s.createElement(t.p,null,"Seen this way, the core question is not about waiting or ordering at\nall. It is about ",s.createElement(t.strong,null,"which kinds of statements a system can safely expose\nbefore it has seen everything"),", and which ones require extra care."),"\n",s.createElement(t.p,null,"Some statements are safe to reveal as soon as they are known locally.\nOthers are only safe once the system has taken steps to ensure that no\nfuture observation will contradict them."),"\n",s.createElement(t.p,null,"That difference is what brings coordination into the picture."),"\n",s.createElement(t.hr),"\n",s.createElement(t.h2,null,"Conclusion: when you need a chisel"),"\n",s.createElement(t.p,null,"Throughout this post, we’ve been looking at how systems stay within\nspec—by ruling out behaviors they won’t allow. What the three lenses\nshow is that there are two very different ways this happens."),"\n",s.createElement(t.p,null,"When a system reacts to evidence, the space of possible executions shrinks\nas information accumulates.\nThis is why replicas can diverge temporarily and still reconcile.\nThey may see events in different orders, but as they exchange\ninformation, their views converge. Evidence removes ambiguity on its\nown, without anyone having to declare which futures are allowed."),"\n",s.createElement(t.p,null,"The hard cases are different.\nHere, the system wants to rule out futures that the world has not ruled\nout yet. It wants to say that nothing else will happen, that a result is\nfinal, or that a particular ordering is settled and cannot be revised.\nThose futures are not impossible—they are merely unwanted."),"\n",s.createElement(t.p,null,"At that point, the system can no longer rely on monotonic accumulation\nalone. The passage of events will not do the work for it. To stay within\nspec, the system has to actively forbid certain futures and get all\nparticipants to respect that decision."),"\n",s.createElement(t.p,null,"That is what we usually call coordination."),"\n",s.createElement(t.p,null,"Coordination is not about slowness or synchronization for its own sake.\nIt is the extra machinery a system needs when correctness depends on\nexcluding futures that might otherwise still occur."),"\n",s.createElement(t.p,null,"This distinction shows up again and again: in transactions and\nisolation levels, in bulk-synchronous execution, and in systems that\nmust act before all uncertainty is resolved. Those connections are\nworth exploring, but they’re for later posts."),"\n",s.createElement(t.p,null,"For now, the takeaway is this. If the futures you want to rule out will\nbe ruled out anyway by the arrival of information, staying within spec\nis easy. If they won’t be, the system will need help."))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?s.createElement(t,e,s.createElement(i,e)):i(e)},l=n(2532),c=n(4967),h=n(3895),m=n(7528),d=n(6163);const u=e=>{var t;let{data:n,location:a,children:i}=e;const o=n.mdx,m=(null===(t=n.site.siteMetadata)||void 0===t?void 0:t.title)||"Title",u=(0,l.c)(o.frontmatter.coverImage),p=o.frontmatter.coverImageCaption;return s.createElement(h.A,{location:a,title:m},s.createElement("article",{className:"blog-post",itemScope:!0,itemType:"http://schema.org/Article"},s.createElement("header",null,s.createElement("h1",{className:"blog-post-title",itemProp:"headline"},o.frontmatter.title),s.createElement("p",null,o.frontmatter.date," • ",o.fields.readingTime),u&&s.createElement("div",{style:{width:"30%",float:"right",marginLeft:"2rem",marginBottom:"2rem",background:"#fafaff",border:"1px solid #eee",borderRadius:"8px",boxShadow:"0 2px 8px rgba(0,0,0,0.04)",padding:"1rem"}},s.createElement(l.G,{image:u,alt:o.frontmatter.title,style:{width:"100%",borderRadius:"4px",marginBottom:p?"0.5rem":"0"}}),p&&p.trim()&&s.createElement("figcaption",{className:"cover-image-caption",style:{textAlign:"left",color:"#666",fontSize:"0.85rem",lineHeight:"1.4",margin:"0"},dangerouslySetInnerHTML:{__html:p}}))),s.createElement("section",{className:"content",itemProp:"articleBody"},i),s.createElement("hr"),s.createElement("footer",null,s.createElement(c.A),s.createElement(d.A))),s.createElement("nav",{className:"blog-post-nav"},s.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0}},s.createElement("li",null,n.previous&&s.createElement(r.Link,{to:n.previous.fields.slug,rel:"prev"},"← ",n.previous.frontmatter.title)),s.createElement("li",null,n.next&&s.createElement(r.Link,{to:n.next.fields.slug,rel:"next"},n.next.frontmatter.title," →")))))},p=e=>{let{data:t}=e;return s.createElement(m.A,{title:t.mdx.frontmatter.title,description:t.mdx.frontmatter.description||t.mdx.excerpt})};function g(e){return s.createElement(u,e,s.createElement(o,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-content-blog-three-specs-on-specs-index-mdx-bc211171a2a8d44c5d09.js.map